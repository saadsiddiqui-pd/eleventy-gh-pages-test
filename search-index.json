[

  {
    "url": "/docs/class_reps/alt/",
    "title": "Class Representation Predicates, alternative",
    "content": "NES.Begin Point. Class Representation predicates Consider the following AST source, definining C++ class Point. cpp.prog source prog cpp:{{ class Point { int x; int y; }; }}. Just like intR defines the memory representation for the type int, we can define PointR to define the memory representation for the class Point. The following assertion describes a struct of type Point where field x contains the integer 1 and field y contains the integer value 5: Example R15 `{Σ : cpp_logic} {σ} (q : cQp.t) : Rep := structR \"Point\" q ** _field \"Point::x\" |-> intR q 1 ** _field \"Point::y\" |-> intR q 5. The above was too concrete; it stored the specific point (1, 5). Just like intR takes as agument a z : Z to denote the mathematical number being represented, we define a Gallina record type t to denote the mathematical model of what is stored: Record t : Type := Mk { p_x : Z ; p_y : Z }. (** Then we can define the general class representation as follows: *) br.lock Definition R `{Σ : cpp_logic} {σ} (q : cQp.t) (m : t): Rep := structR \"Point\" q ** _field \"Point::x\" |-> intR q m.(p_x) ** _field \"Point::y\" |-> intR q m.(p_y). We derive some utility infrastructure to be used later. #[only(cfracsplittable)] derive R. #[only(type_ptr=Point)] derive R. Module R_Unfold. #[only(lazy_unfold(export))] derive R. End R_Unfold. Section with_Σ. Context `{Σ : cpp_logic} {σ}. cpp.spec (default_ctor \"Point\") from source as ctor_spec with ( \\this this \\post this |-> R 1$m (Mk 0 0) ). Section with_R_Unfold. Import R_Unfold. Lemma ctor_ok : verify[source] ctor_spec. Proof. verify_spec; go. Import MyPretty. Show. Here, the proof is stuck. Sometimes, that means that our automation needs help to complete the proof. But here, our program does not implement our specification, so one of the two is buggy. More specifically, this is the goal: _ : this ,, o_field σ \"Point::x\" |-> uninitR \"int\" 1$m _ : this ,, o_field σ \"Point::y\" |-> uninitR \"int\" 1$m --------------------------------------∗ this ,, o_field σ \"Point::y\" |-> intR 1$m 0 ∗ this ,, o_field σ \"Point::x\" |-> intR 1$m 0 Our current state says that fields x and y are not initialized, while our goal requires them being initialized. More specifically, pointer this ,, o_field σ &quot;Point::x&quot; (in C++, &amp;(this-&gt;x)) points to uninitR &quot;int&quot; 1$m in the assumption, and to intR 1$m 0 in the goal. Same for this ,, o_field σ &quot;Point::y&quot; (in C++, &amp;(this-&gt;y)). To continue, we abort the proof, and define AST source1 with a fixed version of the code. Abort. cpp.prog source1 prog cpp:{{ class Point { int x{0}; int y{0}; }; }}. In the fixed AST source1, Point's implicitly generated constructor will initialize fields x and y to 0. We can then easily prove Point's constructor correct against the new AST. Lemma ctor_ok : verify[source1] ctor_spec. Proof. verify_spec; go. Qed. End with_R_Unfold. End with_Σ. NES.End Point."
  },

  {
    "url": "/docs/class_reps/classes/",
    "title": "Classes",
    "content": "Learn about the specification and verification of aggregate data types defined with struct and class."
  },

  {
    "url": "/docs/class_reps/main/",
    "title": "Class Representation Predicates",
    "content": "In this document, we demonstrate how to specify a class. We specify a class in three steps: We write the model of the class, i.e. what a value of this class &quot;means&quot; at an intuitive, abstract level. We write the representation predicate of the class, i.e. how the model is implemented using C++ resources. We specify the member functions using the representation predicate. The Program Here, we define the AST source containing our example C++ program: cpp.prog source prog cpp:{{ struct IntCell { int n{0}; void method() const {} IntCell() = default; IntCell(int _n): n(_n) {} }; void test() { IntCell m; m.method(); } }}. The Model To formalize the type IntCell, we define a type IntCellT as the model of IntCell. A value of type IntCellT describes the data inside an instance of IntCell. Since IntCell is a C++ struct with one field of type int, and we use Rocq type Z of signed integers as model for int (via representation predicate intR), our model will be a Rocq record with one field of type Z. Record IntCellT := MkT { foo_n : Z }. The Representation Predicate In state basics we saw how intR lets us represent the state of a variable of type int. That is, intR is the representation predicate for type int. Next, we define the representation predicate for class IntCell. This will be a function IntCellR : cQp.t -&gt; IntCellT -&gt; Rep. Assertion p |-&gt; IntCellR q m gives ownership q of a IntCell instance whose content matches the model m, living at location p. Concretely, we define IntCellR as follows: Definition IntCellR (q : cQp.t) (m : IntCellT) : Rep := _field \"IntCell::n\" |-> intR q m.(foo_n) ** structR \"IntCell\" q. This definition describes the layout of type IntCell. In many cases, such representation predicate can be generated, but we define it ourselves to explain how these work. We use intR q m.(foo_n) because field IntCell::n contains an integer with value m.(foo_n). We offset that representation predicate with _field &quot;IntCell::n&quot; because this integer does not live at location p (which points to the whole object) but at location p ,, _field &quot;IntCell::n&quot;. This works because when we define a Rep, the x |-&gt; R operator is overloaded to expect x to be a pointer offset o instead of a pointer. structR &quot;IntCell&quot; q means we own q fraction of a IntCell instance; structR is used for all struct and class aggregate C++ types. The Specifications Next, we specify IntCell constructors, destructor, and methods. Such specifications typically need to refer to the object being constructor, destructed, or on which the method is being invoked --- the receiver. To that end, they can use \\this p and then for instance p |-&gt; IntCellR 1$m m. \\this p binds pointer p to the receiver object in the rest of the spec, and p |-&gt; IntCellR 1$m m asserts full ownership of that object. First, we specify the default constructor. cpp.spec \"IntCell::IntCell()\" as default_ctor_spec with ( \\this this \\post this |-> IntCellR 1$m (MkT 0)). Invoking any constructor returns full ownership 1$m to a new object. The IntCell default constructor initializes IntCell::m to 0, so the default model for the new object is MkT 0. Next we specify a non-default constructor IntCell(int); this spec is similar, but IntCell(n) will produce an object with model MkT n instead of MkT 0. \\arg{n} &quot;_n&quot; (Vint n) binds the C++ argument _n's value to the variable n. cpp.spec \"IntCell::IntCell(int)\" as int_ctor_spec with ( \\this this \\arg{n} \"_n\" (Vint n) \\post this |-> IntCellR 1$m (MkT n)). Conversely, IntCell's destructor consumes full ownership 1$m of a IntCell instance with any model, and returns no ownership. cpp.spec \"IntCell::~IntCell()\" as dtor_spec with ( \\this this \\pre{m} this |-> IntCellR 1$m m \\post emp). Next, we have the specification of a method that does nothing. \\prepost P means that P is used in both the pre-condition and the post-condition of the specification. cpp.spec \"IntCell::method() const\" as method_spec with ( \\this this (* Since this method does _not_ modify its receiver, this method doesn't need full ownership of [IntCellR] and just borrows partial ownership [q]. *) \\prepost{q m} this |-> IntCellR q m \\post emp). cpp.spec \"test()\" as test_spec with ( \\post emp)."
  },

  {
    "url": "/docs/common_errors/missing_type_instances/",
    "title": "Dealing with Missing Type Instances",
    "content": "Sometimes, a proof will get stuck because the automation can not prove the a reference is valid. In these cases, the proof usually gets stuck on a reference_to&lt;ty&gt; p obligation. A contrived program that exhibits this behavior is: struct C {}; void test(C c) { C&amp; r{c}; } This proof gets stuck on the following goal: Lemma test_ok : verify[source] \"test(C)\". Proof. verify_spec. go. _ : c_addr |-> CR q --------------------------------------∗ reference_to \"C\" c_addr ∗ (r_addr |-> refR&lt;\"C\"> 1$m c_addr -∗ interp source 1 (wp_decls source [region: \"r\" @ r_addr; \"c\" @ c_addr; return {?: \"void\"}] [] (λ (ρ : region) (free' : FreeTemps), ▷ wp_block source ρ [] (Kfree source (free' >*> FreeTemps.delete \"C&amp;\" r_addr) (Kcleanup source [] (Kreturn (λ v : ptr, ▷ _PostPred_ v))))))) The automation is stuck verifying this goal because it can not prove the reference_to &quot;C&quot; c_addr obligation. Solution: Add a Hint This is most commonly solved using a Typed hint on the class. The following code creates this hint automatically. #[only(type_ptr=\"C\")] derive CR. After introducing the hint, the automation can make progress. In this case, #[only(type_ptr)] derive CR. is also sufficient, because the automation can infer the type C from CR's definition. go."
  },

  {
    "url": "/docs/control_flow/if/",
    "title": "`if` Statements",
    "content": "In this tutorial, we learn how to verify code with if. For this, we'll use the following function which acts like an if. The specification that we will be proving is written in the comment. int cond(bool test, int thn, int els) { if (test) { return thn; } return els; } We'll be proving the following specification: cpp.spec \"cond(bool, int, int)\" with (\\arg{test} \"test\" (Vbool test) \\arg{thn} \"thn\" (Vint thn) \\arg{els} \"els\" (Vint els) \\post[Vint (if test then thn else els)] emp). We start off the proof in the usual way. Goal verify[source] \"cond(bool, int, int)\". Proof. verify_spec; go. (* _ : PostCond _ : thn_addr |-> intR 1$m thn _ : els_addr |-> intR 1$m els _ : test_addr |-> boolR 1$m test --------------------------------------∗ branch.stmt source [region: \"els\" @ els_addr; \"thn\" @ thn_addr; \"test\" @ test_addr; return {?: \"int\"}] test (* &lt;&lt; the value being considered *) (Sseq [Sreturn (Some (Ecast Cl2r (Evar \"thn\" \"int\")))]) (Sseq []) (Kseq (wp_block source [region: \"els\" @ els_addr; \"thn\" @ thn_addr; \"test\" @ test_addr; return {?: \"int\"}] [Sreturn (Some (Ecast Cl2r (Evar \"els\" \"int\")))]) (Kcleanup source [] (Kreturn (λ v : ptr, ▷ _PostPred_ v)))) *) At this point, the proof is stuck on the case split which is reflected by branch.stmt, i.e. a statement-level branch. Manual Verification The simplest thing that we can do at this point is to use the wp_if tactic to tell the automation that we want to consider both cases. wp_if. (* test = true → ... --------------------------------------∗ ::wpS [region: \"els\" @ els_addr; \"thn\" @ thn_addr; \"test\" @ test_addr; return {?: \"int\"}] (Sseq [Sreturn (Some (Ecast Cl2r (Evar \"thn\" \"int\")))]) goal 2 (ID 1965) is: test = false → ... --------------------------------------∗ ::wpS [region: \"els\" @ els_addr; \"thn\" @ thn_addr; \"test\" @ test_addr; return {?: \"int\"}] (Sseq []) *) The first case corresponds to test = true and the second case corresponds to test = false. In both of these, the proof can be discharged trivially, and we can achieve this by running all: go. all: go. Qed. We can also chain using a ;, i.e. wp_if; go.. Goal verify[source] \"cond(bool, int, int)\". Proof. verify_spec; go. wp_if; go. Qed. Automatic Case Splitting In cases such as this one, where the two branches of the if do not re-join before the end of the function, this sort of case splitting is almost always what we want to do. To tell the automation to do this automatically, we can use a hint. Goal verify[source] \"cond(bool, int, int)\". Proof. verify_spec; go. go using smash_delayed_case_no_join_B. Qed. The _no_join part of this is introducing a guard that ensures that at least one side of the if statement can not finish &quot;normally&quot;. This avoids the case split when the rest of the code might be difficult, or expensive, to verify. If we want the automation to always perform the case splits for us, we can use the unguarded hint smash_delayed_case_B in a similar way. Goal verify[source] \"cond(bool, int, int)\". Proof. verify_spec; go. go using smash_delayed_case_B. Qed. This is especially useful for small functions whose implementation is effectively a single if. A Note Splitting the goal directly like this is quite common, but it can be a bit dangerous because it requires that we prove the code after the if statement for each branch. We will discuss specifying &quot;join points&quot; in a subsequent tutorial."
  },

  {
    "url": "/docs/control-flow/",
    "title": "Control Flow",
    "content": "Learn about how to reason about different control flow constructs."
  },

  {
    "url": "/docs/control_flow/loop/",
    "title": "Loop Invariants",
    "content": "In this tutorial, we learn how to specify a simple loop invariant. Require Import bluerock.auto.cpp.prelude.proof. Require Import bluerock.lang.cpp.parser.plugin.cpp2v. The AST source contains our example C++ loop, which increments 0 for 10 times. cpp.prog source prog cpp:{{ int loop() { int i = 0; while (i &lt; 10) { i++; } return i; } }}. Specifying and Verifying a Loop The specification is indeed very simple: the function returns 10, the result of incrementing 0 10 times. cpp.spec \"loop()\" from source as loop_spec with ( \\post[Vint 10] emp ). Section with_cpp. Context `{Σ : cpp_logic}. Context `{MOD : !source ⊧ σ}. Lemma loop_ok : verify[source] \"loop()\". Proof using MOD. verify_spec. go. (* specifying a loop invariant *) wp_while (fun ρ => ∃ i, _local ρ \"i\" |-> intR 1$m i ** [| (i &lt;= 10)%Z |])%I. go. wp_if => Lt10. - (* Less than 10, increment *) go. - (* Not less than 10, break *) go. Qed. End with_cpp. go will not solve the whole proof on its own. The first go will solve the obligations for allocating and initializing the local variable i (at the location i_addr in Rocq). We need to specify a loop invariant for the while-loop. Here, we use the tactic wp_while, which takes a function from the region ρ for local variables to a resource predicate. Our loop invariant is that, each loop interation starts with the full mutable ownership of the local variable &quot;i&quot; (at the location _local ρ &quot;i&quot; which is also i_addr) with some value i that is less than or equal to 10. The next go uses the full ownership of i to reads its current value, and leaves us with the goal of the loop's conditional (i &lt; 10). Here, we use the wp_if tactic to make the case distinction. If the conditional holds, we enter the loop iteration, and we have the full mutable permission of &quot;i&quot; to increment it by 1. That is, the loop body turns _local ρ &quot;i&quot; |-&gt; intR 1$m i into _local ρ &quot;i&quot; |-&gt; intR 1$m i + 1. Note that if this is the last loop iteration, we will then have i + 1 = 10, which is still sufficient to re-establish the loop invariant with i + 1 &lt;= 10. If the conditional does not hold, we have _local ρ &quot;i&quot; |-&gt; intR 1$m i and ¬ i &lt; 10 and the loop terminates. Note that in this case wealso have i &lt;= 10 from the loop invariant (established by the last loop iteration), so we can deduce i = 10 as well as _local ρ &quot;i&quot; |-&gt; intR 1$m 10. This means that return i will read 10 from the local variable and the function returns 10. Note that in both branches, go can perform the reasoning that we explained above on its own, because go has been taught about basic arithmetic reasoning."
  },

  {
    "url": "/docs/debugging/main/",
    "title": "Exploring Programs in Logic",
    "content": "Stepping Through Functions In this tutorial we will learn how to use SkyLabs' automation to step through functions and verify them line-by-line. We'll consider the following function with the specification written in the documentation comment. /** * \\post emp */ void test() { int x = 0; x++; x--; } To understand this, we'll use SkyLabs' automation to teach us about the representation of the program state and how it evolves. Exploring a C++ Function with SkyLabs Automation With the specification, we can step through the function using the SkyLabs automation. The automation is structured to work like symbolic debugger. To start, we set up a proof of the function: Lemma test_ok : verify[source] \"test()\". Proof. verify_spec. At this point, the goal looks like the following _ : denoteModule source (* &lt; the program that we are working with *) --------------------------------------□ _ : PostCond (* &lt; the post condition, we'll need this later *) --------------------------------------∗ ::wpS (* &lt; running a statement *) [region: return {?: \"void\"}] (* &lt; the variables in scope *) (Sseq [Sdecl [Dvar \"x\" \"int\" (Some (Eint 0 \"int\"))]; Sexpr (core.Epostinc (Evar \"x\" \"int\") \"int\"); Sexpr (core.Epostdec (Evar \"x\" \"int\") \"int\")]) Just like in a debugger, we can step forward in the program using the run1 tactic, which will attempt to prove that the next step of the program is safe and step through it. run1. This invocation took us to the evaluation of the integer constant 0 that is the initializer for x. We can continue to step through the program with more invocations of run1, then complete the proof with Qed. If we are just exploring, we can use Abort instead of Qed to abort the proof. run1. After we complete the initialization, note that we get access to the ownership of the x variable. In particular, the goal reads: _ : x_addr |-> intR 1$m 0 --------------------------------------∗ ::wpS [region: \"x\" @ x_addr; return {?: \"void\"}] (Sexpr (Epostinc (Evar \"x\" \"int\") \"int\")) Above the line, we have the current state, i.e. full ownership of the program location for the variable x (x_addr corresponds to the pointer &amp;x in C++). Below the line, we see that we are evaluating the post-increment expression (x++). We can now continue stepping through the program. It takes three steps to get through the post-increment. run1. (* start evaluating the expression statement *) run1. (* evaluate `x` *) run1. (* evaluate the post-increment *) At this point, we see that the value of x has been updated to 1 (though this form is unreduced), and we are left to prove the decrement. _ : x_addr |-> intR 1$m (0 + 1) --------------------------------------∗ ::wpS [region: \"x\" @ x_addr; return {?: \"void\"}] (Sexpr (Epostdec (Evar \"x\" \"int\") \"int\")) Another 3 run1s will get us through the decrement. run1. run1. run1. Now, we can see the value of x is updated one more time. _ : x_addr |-> intR 1$m (1 - 1) --------------------------------------∗ destroy_val source \"int\" x_addr (∀ p : ptr, p |-> primR \"void\" 1$m Vvoid -∗ ▷ _PostPred_ p) At this point, we have reached the end of the function source code, but we are not quite done yet. In particular, we still need to destroy all of the stack allocated variables. Even though there are no destructors to run, the C++ machine must take the stack resources back which is captured by destroy_val. In particular, this says that we need to destroy an int value at the location x_addr. Again, we can step through this with run1. run1. In this case, run1 not only stepped through the deallocation, but it also finished the proof so we don't get to see the final state. While this says that the post-condition was provable, it doesn't really let us see the final state. To see the final state, we can undo the last action and then take even smaller steps using the step tactic. Undo. step. (* take a smaller step *) After the smaller step, we see that the ownership of x_addr has been &quot;consumed&quot; by the destroy_val step. Though there is still some complexity in the goal. Here that complexity is due to the way that values (including void &quot;values&quot;) are returned; however, we won't go into that detail here. In general, while step is useful to see the fine-grained reasoning steps that the automation is using, it sometimes exposes internal details of the semantics that are not stable. In such cases, it is often useful to simply run step again to try to simplify the goal. We can continue to step using step, run1, or go. run. This finishes the proof allowing us to close the proof with Qed; however, in many cases during this sort of exploration we will not be able to close the proof, e.g. because there is a bug in the specification. If we want to keep the debugging proof script intact, we can use the Abort command to exit the proof without finishing it. Abort."
  },

  {
    "url": "/docs/fractional-sharing/intro/",
    "title": "Sharing with Fractional Permissions",
    "content": "Read-only sharing of data is pervasive in programs from small to large. Limiting mutability is especially crucial when avoiding data races in concurrent programs since these lead to undefined behavior; however, fine-grained, sequential immutability is a powerful tool when building and reasoning about programs. Fractional Permissions The most common way to describe sharing of resources in separation logic is using fractional permissions. Rather than having complete ownership of a resource, e.g. a program location, you can have a (fractional) part of the ownership and other threads or data structures can own the other parts. Consider the primR representation predicate for describing an initialized program location storing a primitive. We can check the type of this using Check primR. (* primR : type → cQp.t → val → Rep *) The second to last argument is a cQp.t which is a (const-annotated, the c) positive fraction (the Qp). For the purpose of sharing, we'll focus only on the Qp. When we write these in the common notation, we use q$m or q$c, q is the fraction. Dividing Ownership The benefit of using fractions is that they can easily be split up and re-combined. For example, if we have full ownership of an integer, we can divide it into two parts and give those two parts to different threads or data abstractions. Formally, this is demonstrated by the following: Goal forall (p : ptr) (z : Z), p |-> intR 1$m z |-- p |-> intR (1/2)$m z ** p |-> intR (1/2)$m z. Proof. work. Qed. This process can be repeated arbitrarily. Generalizing the theorem above, we see Goal forall (p : ptr) (q : Qp) (z : Z), p |-> intR q$m z |-- p |-> intR (q/2)$m z ** p |-> intR (q/2)$m z. Proof. work. Qed. This also works out for spitting into other numbers of pieces, e.g. if we want to share a value between three threads, we can divide it into three equal parts. Goal forall (p : ptr) (q : Qp) (z : Z), p |-> intR q$m z |-- p |-> intR (q/3)$m z ** p |-> intR (q/3)$m z ** p |-> intR (q/3)$m z. Proof. work. Qed. Symmetric fractions are often quite easy to work with, but it can also be helpful to distinguish between two parts, e.g. if the main thread retains some ownership and gives other ownership to workers. To capture this pattern, it is common to use non-symmetric fractions, e.g. the main thread retains 2/3 ownership while the worker thread gets 1/3 ownership. Combining Ownership In addition to splitting, ownership can also be combined. Goal forall (p : ptr) (q : Qp) (z : Z), p |-> intR (q/2)$m z ** p |-> intR (q/2)$m z |-- p |-> intR q$m z. Proof. work. Qed. In general, all of the theorem that we proved in the previous section also hold for combining. Consistency A crucial property of fractional ownership is that all of the ownership must be consistent. Concretely, if I have two fractions of ownership of the same location at unknown values, then those to values must be the same. This is demonstrated by the following theorem: Goal forall (p : ptr) (q : cQp.t) a b, p |-> intR (q / 2)$c a ** p |-> intR (q / 2)$c b |-- [| a = b |] ** p |-> intR q$c a (* equivalently &lt;&lt;intR q b>> *). Proof. (* ... proof elided ... *) Qed. Consistency is a powerful reasoning feature when reasoning through abstractions and concurrent invariants, but in simple sequential code it is mostly unnecessary. &quot;Full&quot; Ownership &amp; Fractional Validity It is common to talk about fraction 1 as &quot;full ownership&quot;. This is because the fractional ownership of an object is constrained to be greater than 0 and less than or equal to 1[1]. Concretely, this can be seen in the following theorem: Goal forall (p : ptr) q (z : Z), p |-> intR q$c z |-- [| (0 &lt; toQ q)%Q ∧ (q ≤ 1)%Qp |] ** True. Proof. (* ... proof elided ... *) Abort. This principle is useful when capturing limited sharing. For example, take a reader-writer lock. Acquiring read-permission to the lock can yield an unknown amount of ownership and acquiring write permission can yield full ownership. Using fractional validity, we can prove that it is not possible to simultaneously have a read and write fraction since: Goal forall (p : ptr) (q : Qp) z, p |-> intR 1$m z ** p |-> intR q$c z |-- False. Proof. work. Abort. A more idiomatic characterization of reader-writer locks would avoid the const-qualification and use only the Qp. Limiting the fraction to 1 is idiomatic, but not strictly necessary in the core separation logic. This property is captured separately through the FracValid typeclass. ↩︎"
  },

  {
    "url": "/docs/functions/",
    "title": "Functions",
    "content": "Learn about basic function verification."
  },

  {
    "url": "/docs/functions/specification/",
    "title": "Function Specifications",
    "content": "This file is based on the following code. const int foo = 3; void test() {} void int_arg(int x); int int_return(); void ref_arg(int&amp; r); void rv_ref_arg(int&amp;&amp; r); Function-level specifications are at the heart of modular verification. In BRiCk, function specifications are written in a syntax inspired by Doxygen using \\ commands. The Post-condition - \\post All function specifications must end with a \\post line. If the function returns void, then the syntax is the following: cpp.spec \"test()\" with (\\post emp (* ownership to return *)). Returning Values - \\post[] Functions that return values use a special form of \\post where the return value is placed in []. For example, if the function int_return() always returned the value 0, then the specification could be written. cpp.spec \"int_return()\" with (\\post[Vint 0] emp). If existential quantifiers are necessary to describe the return value, then these can be added using {}. For example, if we want to say that int_return() returns an arbitrary integer, then we could write the following: cpp.spec \"int_return()\" with (\\post{v}[Vint v] emp). Multiple quantifiers are supported as well as quantifiers with type annotations. cpp.spec \"int_return()\" with (\\post{(v : Z) (w : Z)}[Vint (v + w)] emp). Spatial Pre-conditions - \\pre Spatial ownership can be added to the pre-condition of the function using \\pre. For example, cpp.spec \"test()\" with (\\pre _global \"foo\" |-> intR 1$c 3 \\post emp). This specification states that the function test() must be called with full (constant) ownership of the global variable foo which must have value 3. \\pre supports adding implicit existential quantifiers for logical variables using {} notation. For example, cpp.spec \"test()\" with (\\pre{x : Z} _global \"foo\" |-> intR 1$c x \\post emp). Pure Pre-conditions - \\require Non-spatial facts, e.g. x &lt; 5, can be added to the pre-condition using \\require. As with \\pre, this supports implicit existentials. cpp.spec \"test()\" with (\\require{x : Z} x &lt; 5 \\post emp). Primitive Arguments - \\arg Arguments of primitive types, e.g. int, char, C*, etc, are described using the \\arg command, which takes a string name for documentation purposes and a value that the argument must match. For example, to state that the argument to int_arg(int) must be less than 3, you could write the following: cpp.spec \"int_arg(int)\" with (\\arg{x : Z} \"x\" (Vint x) \\require x &lt; 3 \\post emp). As with the other commands, the {}s introduce existential quantifiers. By convention, the name in the string should match the name of the formal, but this is not currently required. cpp.spec is implicitly adding the pre- and post- ownership for the argument to this specification and can do this because primitives of this form are guaranteed to have trivial destructors."
  },

  {
    "url": "/docs/functions/verification/",
    "title": "Verifying Some Examples",
    "content": "In this tutorial, we consider specifications and verifications of very simple programs. These include additions of integers and a swap function. Simple Functions Import the C++ verification environment: Require Import bluerock.auto.cpp.prelude.proof. Import the command cpp.prog to inline our C++ functions in Rocq. Require Import bluerock.lang.cpp.parser.plugin.cpp2v. Define AST source containing our example C++ functions. cpp.prog source prog cpp:{{ int add(int x, int y) { return x + y; } unsigned int add(unsigned int x, unsigned int y) { return x + y; } void swap(int* px, int* py) { int t = *px; *px = *py; *py = t; } }}. Specifying and Verifying Integer Addition We can specify our functions as follows. cpp.spec \"add(int, int)\" from source as add_spec with ( \\arg{x} \"x\" (Vint x) \\arg{y} \"y\" (Vint y) (* - 2^31 ≤ x + y ≤ 2^31 - 1 *) \\require bitsize.bound bitsize.W32 Signed (x + y) \\post[Vint (x + y)] emp ). cpp.spec \"add(unsigned int, unsigned int)\" from source as add_unsigned_spec with ( \\arg{x} \"x\" (Vint x) \\arg{y} \"y\" (Vint y) \\post[Vint (trim 32 (x + y))] emp ). Here, add_spec requires strong conditions on the signed arguments x and y: the sum of x and y should neither underflow nor overflow for 32-bit integers. That is, x + y should be in the range [-2^31,2^31). As such, the function will return the sum as-is. \\require P adds a pure Rocq proposition (P : Prop) as a pre-condition to the specification. On the other hand, add_unsigned_spec does not require any condition on the unsigned integers x and y. Instead, it returns, in the post-condition, the sum of x and y potentially truncated to 32 bits (trim 32 (x + y)), covering the case where the sum overflows. In case that we know that the sum does not overflow, i.e., x + y &lt; 2^32, we can use modulo.useless_trim to get the equality trim 32 (x + y) = x + y. About modulo.useless_trim. (* modulo.useless_trim : ∀ (a : Z) (bits : N), (0 ≤ a &lt; 2 ^ bits)%Z → a = trim bits a *) (Note that as x and y are unsigned, we do have 0 ≤ x + y.) Section with_cpp. Context `{Σ : cpp_logic}. Context `{MOD : !source ⊧ σ}. Lemma add_spec_ok : verify[source] \"add(int, int)\". Proof. verify_spec. go. Qed. Lemma add_unsigned_spec_ok : verify[source] add_unsigned_spec. Proof. verify_spec. go. Qed. End with_cpp. With the correct specifications and the fact that the code is very simple, the go tactics of the the SkyLabs' automation can discharged the proofs without extra intervention. One can try to change the specifications, for example by removing the required resources or the bitsize.bound pre-condition, to see that the automation may fail to finish the proofs. Note that we can use the verify[source] notation with either the C++ function name or the Rocq specification name. In case of the former, the notation will look up in the environment to find the corresponding Rocq specification, e.g., verify[source] will find that add_spec is the specification for add(int, int) and generate the expected lemma statement. Specifying and Verifying Swap cpp.spec \"swap(int*, int* )\" from source as swap_spec with ( \\arg{px} \"px\" (Vptr px) \\arg{py} \"py\" (Vptr py) \\pre{x} px |-> intR 1$m x \\pre{y} py |-> intR 1$m y \\post px |-> intR 1$m y ** py |-> intR 1$m x ). The specification for swap requires in the pre-condition the full, mutable ownership (with fraction 1$m) of both locations px and py, with some intial values x and y, respectively. The result, as stated in the post-condition, is that the values x and y are swapped. Section with_cpp. Context `{Σ : cpp_logic}. Context `{MOD : !source ⊧ σ}. Lemma swap_ok : verify[source] swap_spec. Proof. verify_spec. go. Qed. End with_cpp. Again, the automation can solve this goal on its own. If, however, we have a specification with insufficient pre-conditions, such as not_enough_resources_swap_spec below, where we do not have full, mutable ownership of px and py ((1/2)$c means we only have half the fraction, with only read permission), then the automation will fail to finish the proof. cpp.spec \"swap(int*, int* )\" from source as not_enough_resources_swap_spec with ( \\arg{px} \"px\" (Vptr px) \\arg{py} \"py\" (Vptr py) \\pre{x} px |-> intR (1/2)$c x \\pre{y} py |-> intR 1$m y \\post px |-> intR 1$m y ** py |-> intR 1$m x ). Section with_cpp. Context `{Σ : cpp_logic}. Context `{MOD : !source ⊧ σ}. Example not_enough_resources_swap_not_ok : verify[source] not_enough_resources_swap_spec. Proof. verify_spec. go. Fail Qed. Abort. End with_cpp."
  },

  {
    "url": "/docs/primitive_reps/main/",
    "title": "Primitive Data",
    "content": "Primitive Reps The BRiCk program logic provides several representation predicates for primitive C++ state. primR ty q v -- initialized program location storing v of type ty (can not store raw values) uninitR ty q -- uninitialized program location of type ty anyR ty q -- a program location of type ty with completely unknown contents (initialized, uninitialized, or raw) Convention: By convention, representation predicates end with a capital R, e.g. primR, fooR, etc. primR The most common predicate for talking about the value at a program location is primR. About primR. (* primR : type -> cQp.t -> val -> Rep *) primR ty q v captures the q ownership of the initialized program cell with type ty and value v. Some examples, Check primR \"int\" 1$m (Vint 3). (* &lt;&lt; mutable integer cell containing value 3 *) Check primR \"char\" 1$m (Vchar 65). (* &lt;&lt; mutable character cell containing value 'A' *) Check primR \"long int\" 1$c (Vint 1000). (* &lt;&lt; constant long int cell containing value 1000 *) Because primR captures initialized program state, it implies that the value (the last argument) stored at the location is well typed at the type of the location. For instance, a char cannot store a Vint value, an int cannot store a Vchar value, and neither can store a value that overflows the storage. In other words, even if val has &quot;too many&quot; values, primR ty q v can rule out the values of v that are not appropriate for ty. Formally, this is captured by the following: Lemma primR_has_type : forall (p : ptr) ty q v, p |-> primR ty q v |-- validP&lt;ty> v. Proof. Admitted. Because primR is so common, BRiCk provides notations for the basic types with their canonical type representations. For example, Print intR. Print ulongR. Print ulonglongR. Print charR. Print wcharR. uninitR -- Uninitialized Data Unlike high-level languages, C++ does not mandate that all variables are initialized. For instance, variable x is not initialized in the following code. void f() { int x; // _local \"x\" |-> uninitR \"int\" 1$m } BRiCk provides the Rep-predicate uninitR to capture uninitialized program cells of a particular type. About uninitR. (* uninitR : type -> cQp.t -> Rep *) Formally, uinitR ty q captures an uninitialized program location of type ty. However, because uninitialized data is often transitory, explicitly writing this predicate is quite rare. In practice, we often prefer anyR to capture a value that may or may not be initialized. anyR -- Possibly Uninitialized Data The anyR Rep-predicate captures a program location that is either initialized or not. The type of anyR is the same as uninitR. About anyR. (* anyR : type -> cQp.t -> Rep *) The anyR ownership can be particularly useful when describing a program state at the beginning of a loop. For example, suppose that you have the following do-while loop. int x; // _local \"x\" |-> uninitR \"int\" 1$m do { // _local \"x\" |-> anyR \"int\" 1$m x = f(); } while (x > 0); Before we enter the loop the first time, we know that x is uninitialized, but on subsequent iterations of the loop, x might be initialized. To capture this pattern, we can use anyR to say that the loop will execute correctly regardless of whether x is initialized or not. Recap Here we learned about the three most common predicates for describing primitive data, primR for initialized data; anyR for data that may or may not be initialized; and uninitR for data that is known to be uninitialized. These predicates alone are sufficient for describing the behavior of many simple programs."
  },

  {
    "url": "/docs/rep_hints/main/",
    "title": "Hints about Reps",
    "content": "Here, we show some hints about Reps that we can declare to get proofs unstuck. First we setup our automation and use an example program: Require Import bluerock.auto.cpp.prelude.proof. Require Import bluerock.lang.cpp.parser.plugin.cpp2v. Define AST source containing our example C++ program. This is the same as in the earlier tutorial. cpp.prog source prog cpp:{{ struct IntCell { int n{0}; void method() const; }; void test() { IntCell m; m.method(); } }}. Section with_cpp. Context `{Σ : cpp_logic}. Context `{MOD : source ⊧ σ}. Parameter R : cQp.t -> N -> Rep. cpp.spec (default_ctor \"IntCell\") as ctor_spec with (\\this this \\post this |-> R 1$m 0). cpp.spec (dtor \"IntCell\") as dtor_spec with (\\this this \\pre{m} this |-> R 1$m m \\post emp). cpp.spec \"IntCell::method() const\" as method_spec with (\\this this \\prepost{q m} this |-> R q m \\post emp). cpp.spec \"test()\" as test_spec with (\\post emp). Lemma test_ok : verify[source] test_spec. Proof. verify_spec; go. TODO: explain here the goals we're stuck on, and the hints we need. #[global] Declare Instance R_learn : Cbn (Learn (any ==> learn_eq ==> learn_hints.fin) R). progress work. #[only(cfracsplittable)] derive R. progress work. #[only(type_ptr=\"IntCell\")] derive R. progress work. go. Qed. End with_cpp."
  },

  {
    "url": "/docs/simple/test/",
    "title": "Very First Verification",
    "content": "Verifying a Simple Function Our first proof will be about a very simple function: void test() { } This is trivial, but it lets us learn the basics about verification. Setting up the Verification Import the C++ verification environment: Require Import bluerock.auto.cpp.prelude.proof. Import a command to specify our C++ program &quot;inline&quot;. Require Import bluerock.lang.cpp.parser.plugin.cpp2v. Define AST source containing the code above: cpp.prog source prog cpp:{{ void test() { } }}. Some more setup is omitted for now. Specifying the Expected Behavior We must first specify what the test function does. cpp.spec \"test()\" from source as test_spec with (\\post emp). This specification states that test() does nothing. The \\post emp tells you that the function doesn't return any resource, but we'll get into that more later. Verifying the Function Now, we can set up the verification by posing a Lemma. Lemma test_ok : verify[source] \"test()\". Proof. This sets up a theorem for our function that states that the function satisfies the specification, and that invoking the function as specified will not produce any undefined behavior. Since this is a particularly simple function, the proof is also simple. This proceeds in two stages: We use verify_spec to begin the proof: our goal becomes a goal about the concrete function body. Next we use the go tactic to symbolically execute the body of the function and prove the post-condition. Idiomatically, we chain these two tactics together using a ; which leads us to the following proof script. verify_spec; go. Qed. The Qed ends the proof and Rocq tells us that the proof is checked. Congratulations! You've walked through your first proof."
  },

  {
    "url": "/docs/state_basics/main/",
    "title": "Basics about Program State",
    "content": "The Program State In this tutorial we will focus on the very basics of separation logic, primarily on primitive types. Separation logic is a logic of resource that can be &quot;owned&quot;. While this concept is somewhat abstract, seeing a few examples should clarify things. Consider the following program with a comment representing the program state at each line. void test() { // emp int x = 0; // _local \"x\" |-> intR 1$m 0 x++; // _local \"x\" |-> intR 1$m 1 } In the first line, there are no variables, so the state is empty, so we write emp. After the first line runs, there is now a new &quot;program location&quot; allocated. That program location is the cell that stores the value of the variable x. The location has type int, and the value stored in the cell is 0. This state is captured by the second line: _local \"x\" |-> intR 1$m 0 The |-&gt; is the &quot;points-to&quot; operator which takes a left-hand-side that is a pointer and the right-hand-side describing a portion of the program state at that pointer. The _local &quot;x&quot; is effectively the pointer &amp;x. The right hand side, intR 1$m 0, represents a mutable program location of type int with value 0. (The 1 in 1$m is a fraction, used to specify fractional ownership, but we will ignore it for now and always use 1.) Incrementing x changes the value stored in the cell. The resulting state is described by the following assertion. _local \"x\" |-> intR 1$m 1 Here, the pointer did not change, but the value stored at the pointer changed from 0 to 1. Multiple Locations Now suppose that we declare a new variable. int y = 10; Similarly to what we've seen, the state of y after this declaration is captured by _local \"y\" |-> intR 1$m 10 However, the full program state contains both of these program locations. To capture multiple disjoint program locations, we connect the two assertions using a ** (or in unicode ∗). The ** is called the &quot;separating conjunction&quot; and is pronouned &quot;star&quot;. Thus, the full state after this declaration is captured by _local \"x\" |-> intR 1$m 1 ** _local \"y\" |-> intR 1$m 10 The crucial feature of the separating conjunction is that it implicitly captures the disjointness of the two locations. Without the disjointness, we would need to explicitly state that _local &quot;x&quot; does not equal _local &quot;y&quot;. In this case, explicitly stating the disjointness would not be overly cumbersome, but as the number of pointers grows and abstractions hide internal pointers, explicit disjointness without separation logic quickly becomes intractable. The Frame Rule The benefit of disjointness is that it enables highly modular reasoning. For example, suppose that we now increment the value of y, i.e. y++; To reason about this step, we only need to think about the &quot;program cell&quot; for _local &quot;y&quot;, i.e. the resource _local &quot;y&quot; |-&gt; intR 1$m 10. We call this resource the &quot;footprint&quot; of the step. The other resources, in this case _local &quot;x&quot; |-&gt; intR 1$m 1 are called the &quot;frame&quot;. In general, the footprint of a step can change, while the frame stay unchanged. Thus, after the update, the state looks like the following: _local \"x\" |-> intR 1$m 1 ** _local \"y\" |-> intR 1$m 11 Recap With this we have seen the basics of how separation logic works in a very small example. See the Further Reading section for more materials on separation logic."
  },

  {
    "url": "/reference/bluerock.auto.core.hints.cancelx_notation/",
    "title": "DSL for defining hints",
    "content": "This file defines a DSL to simplify to definition and proof of hints. The same language is usable with Bwd, Fwd and CancelX hints. Fwd hints are still special since they're run at a different phase. CancelX Hints The following syntax defines a CancelX hint: #[program] Definition my_cancelx_C := \\cancelx \\masks m => f (* [m : MatchingMode] and [f : FUpdCfg]; see classes/cancelx.v *) \\with a \\guard isGood a (* this is like \\require *) \\guard_with b (* inserts [guard_not_provable (guard_with b)] and introduces [guard_with b] *) \\with b \\using P a b (* match and _use_ [P a b]; see [base.Use] documentation *) \\consuming PC a b (* match and always consume [PC a b]; see [base.Drop] documentation *) \\preserving PP a b (* match and always preserve [PP a b]; like \\prepost PP; see [base.Preserve] documentation *) \\intro c (* c is only visible in \\deduce and \\through *) \\deduce P' a b c (* remaining resource *) \\bound x (* x is only visible in \\proving, \\through and \\frame *) \\bound_existential z (* like \\bound except that [z] will not match arbitrary terms, only existentially quantified variables *) \\instantiate z := foo (* applying this hint causes the existentially quantified variable [z] to be instantiated with [foo] *) \\bound_guard good_instance x (* like \\bound but meant for discriminating between matches *) \\proving Q a b x z (* final goal to match *) \\goal_trigger QQ a b x \\whole_conclusion (* only fire if the hint matches all conjuncts of the conclusion *) \\exist y (* y is only visible in \\through *) \\through Q' a b c x y (* new goal *) \\framed_var w (* bind [w] useable only in \\frame clauses *) \\frame L a b x w (* bi-abduction frame; once Q' ** QQ are dischared, L can become a new assumption *) \\end. Next Obligation. (* Proof of the hint *) Qed. The resulting hint statement is equivalent to: ∀ a, isGood a -> ∀ b, P a b ** PC a b ** PP a b |-- ∃ c, P' a b c ** PP a b ** (∀ x z (_ : good_instance x), (∃ y, {instantiate z := foo} ** Q' a b c x y ** QQ a b x) -* Q a b x ** QQ a b x ** (∃ w, L a b x w)) Note that the variables' visibility follow the rules indicated in comments and not the visitibilty rules of the quantifiers in the above formula. Case in point, even though Q and QQ appear under ∃ c (the intro-ed variable), they cannot refer to c. Bwd Hints The following syntax defines a Bwd hint: #[program] Definition my_bwd_hint_C := \\bwd \\with a \\bound b (* in a bwd hint, \\bound is the same as \\with *) \\proving Q a b \\goal_trigger QQ a b \\intro c \\through Q' a b c \\end . Next Obligation. (* Proof of the hint *) Qed. The resulting hint statement is equivalent to: ∀ a b, (∃ c, Q' a b c ** QQ a b) |-- Q a b ** QQ a b Fwd Hints The following syntax defines a Fwd hint: #[program] Definition my_fwd_hint_C := \\fwd \\with a \\consuming P a \\using PP a \\intro b \\deduce P' a b \\end . Next Obligation. (* Proof of the hint *) Qed. The resulting hint statement is equivalent to: ∀ a, P a ** PP a |-- ∃ b, P' a b ** PP a Binders Each keyword that declares a predicate can additionally bind one or more variable with an appropriate binder. Here is how to desugar those variable declarations: \\guard{a} isGood a ~> \\with a \\guard isGood a \\consuming{a} P a ~> \\with a \\consuming P a \\using{a} PP a ~> \\with a \\using PP a \\deduce{b} P' b ~> \\intro b \\deduce P' b \\proving{x} Q x ~> \\bound x \\proving Q x \\goal_trigger{x} QQ x ~> \\bound x \\goal_trigger QQ x \\through{y} Q' y ~> \\exist y \\through Q' y \\frame{a} P a ~> \\framed_var a \\frame P a"
  },

  {
    "url": "/reference/bluerock.auto.core.hints.orient/",
    "title": "Syntax for defining hints",
    "content": "This module defines notations that can convert certain BI facts into hints for the automation. To this end it offers several notations that can parse various BI (bi-)entailments into forward, backward, and cancellation hints. Simple Examples Forward hints Given a proof H : P |-- Q, we use the notation [FWD] H to obtain a forward hint Fwd P, which exchanges premise P for premise Q. Lemma hintPQ : P |-- Q. Proof. (* proof of the hint *) Qed. Definition hintPQ_F (* : Fwd P *) := [FWD] hintPQ. As a convention, we use the suffix _F for forward hints, _B for backward hints, and _C for cancellation hints. Backwards hint Given a proof H : P |-- Q we use the notation [BWD] H to obtain a backward hint Bwd Q, which exchanges conclusion Q for conclusion P. Definition hintPQ_B (* : Bwd P *) := [BWD] hintPQ. Cancellation hints Given a proof H : P |-- P' ** (Q' -∗ Q), we use the notation [CANCEL] H to obtain a cancellation hint Cancel P Q that exchanges premise P for premise P', and conclusion Q for conclusion Q'. Lemma hintPQ' : P |-- P' ** (Q' -∗ Q). Proof. (* proof of the hint *) Qed. Definition hintPQ'_C (* : Cancel P Q *) := [CANCEL] hintPQ'. Advanced Features The notations can parse (bi-)entailments that introduce new facts into the Rocq context. For example, H : P |- ∃ (x : Z) (Hx : 1 &lt;= x), Q x is turned into a forward hint Fwd P that introduces (x : Z) and (Hx : 1 &lt;= x) into the Rocq context and exchanges P for Q x via [FWD] H. The notations can also parse existential binders in the conclusion. These existentials are hoisted to the very top-level of the conclusion. For example, [CANCEL] H turns H : P |- (∃ x : Z, Q' x) -∗ Q into a cancellation hint Cancel P Q such that it transforms the goal P |- R ** Q into P |- ∃ x : Z, R ** Q' x. Re-Orienting Hints All notations in this module also optionally re-orient bi-entailments. Given H : P -|- Q, we can derive Fwd Q (instead of Fwd P) via [FWD&lt;-] H. (Note the backward arrow.) Specification The full set of notations is: [FWD], [BWD], [CANCEL] or, equivalently, [FWD-&gt;], [BWD&lt;-], [CANCEL-&gt;] (note the backward arrow on [BWD], which indicates the default direction of a backward hint) or, to reverse bi-entailments, [FWD&lt;-], [BWD-&gt;], [CANCEL&lt;-]. The general form of hints parsed by the notations is: P |-- ∃ x1 .. xN, P' ** ((∃ y1 .. yM, Q') -* Q) where P' can mention x1 .. xN, Q' can mention x1 .. xN and y1 .. yM, and P and Q may not mention either set of binders. The tactics will parse lemmas whose type ends in one of the above forms by introducing universal quantifiers and implications it encounters while traversing the type and mirroring them in the resulting hint."
  },

  {
    "url": "/reference/bluerock.auto.cpp.Arith/",
    "title": "Tactics for arithmetics",
    "content": "Main tactics: arith_solve : solve (in)equalities. invokes lia after adding to the Rcoq context facts about the non-linear operations in the conclusion. remove_useless_mod_a : remove occurrences of mod (aka trim). This and the above are co-recursive. mod_simpl : uses modular (a mod b) reasoning to simplify goals. norm : fully normlize closed terms of selected types. often invoked as norm numeric_types"
  },

  {
    "url": "/reference/bluerock.auto.cpp.auto_frac.hints/",
    "title": "Automatic Fractional Splitting",
    "content": "This file provides hints based on AsFractional and AsCFractional and meant to automate fractional splitting, recombining and the picking of fractions. It uses the typeclasses Recombine(C)Frac, Half(C)Frac and (C)FracDiff to parse fraction terms and symbolically calculate the sum of fractions (including cQp.t), subtraction of fractions and halving as well. Subtraction is calculated symmetrically in such a way that we don't need to know for sure which fraction is greater than the other. The hints proper are: recombine_(c)frac_F recombine_(c)frac_same_F split_specific_(c)frac_C pick_(c)frac_and_split_C They are meant to recombine premises whenever possible, cancel conclusion terms where the fraction is know and and picking a safe choice for a fraction when fractions are existentially quantified. The hints are prioritized in such a way that we parcel out all the fractions that are known before instantiating existential quantifiers. Work in progress: the classes for parsing and normalizing fractions are provisional. They are expected to be brittle and slow and a solution based on more complete reflection is in the works. Limitations: the fraction picking hints are robust in the face of a need to split the same premise repeatedly any number of times but for existentially quantified fractions that are referenced in multiple terms, the choice will not take that fact into consideration. For that reason, fraction picking hints are, at least at first, opt-in."
  },

  {
    "url": "/reference/bluerock.auto.cpp.breakpoints/",
    "title": "Using breakpoints",
    "content": "Suggested uses of breakpoints: resource splitting &amp; ghost reasoning: stop the automation at exactly the right point to subdivide a physical resource (or do ghost reasoning, e.g. inserting a fupd and opening an invariant). self-documenting workarounds for learning existentials: stop the automation just prior to a known-bad evar instantiation (subsequently instantiating it manually or using the learner to do so). stepping over C++ statements using the automation wuntil wuntil pat tac adds a breakpoint on the first match of pat, runs tac, and then removes the first match of BREAKPOINT pat. The breakpoint being removed might not be the one added, if tac is doing something interfering with the breakpoints. For example, the following call asks go to run and then stop before the function returns. wuntil (Sreturn _) go. wthrough wthrough pat tac_body tac_post adds a breakpoint on the first match of pat, at which point it: attempts to progress to the new breakpoint using tac_body removes the breakpoint attempts to proceed using tac_post."
  },

  {
    "url": "/reference/bluerock.auto.cpp.cpp_proof/",
    "title": "The `verify` notation",
    "content": "The verify[ tu ] spec provides a convenient way to write theorem statements for proofs that automatically computes the dependencies, which are the specifications of functions called by the function being verified. If dependencies might be missing, you can use verify?[ tu ] spec to ignore missing-specification errors. When the context contains an assumption of the form &lt;module ⊧ σ, one can write verify[_] (or verify?[_]) to automatically infer module. Lemma ctor_ok : verify[ module ] ctor_spec. Proof. ... Qed."
  },

  {
    "url": "/reference/bluerock.auto.cpp.delayed_case_tactics/",
    "title": "Join points",
    "content": "This file provides two tactics wp_if and wp_switch, with variants, for dealing with join points produced by if and switch statements. wp_if -- advance past a branch.stmt performing an immediate case split. This should only be used if the continuation is &quot;simple&quot;. wp_if wpp -- wpp is a region -&gt; WithPrePost (specify with function spec syntax) that describes the branches as a function with the given specification. Unlike a function call, the branches get access to, but must preserve the frame. wpe_if wpp -- similar to wp_if wpp but applies to conditional expressions. wpe_if PQ wpp -- similar to wpe_if wpp but PQ, a region -&gt; mpred, specifies a postcondition to be proved after freeing the temporaries of the enclosing expression. wp_switch -- same as wp_if but for branch.cases wp_switch wpp -- same as wp_if wpp but for branch.cases wp_switch P -- where P is a region -&gt; mpred states that P is the (big-footprint) specification of the join point."
  },

  {
    "url": "/reference/bluerock.auto.elpi.cpp_class/",
    "title": "The `cpp.class` command",
    "content": "Usage #[verbose, debug] #[unsafe_learn_hint=local|export|global|none] (* Register unsafe learning hint? (default `global`) *) cpp.class &lt;matcher> [ prefix \"prefix\" ] from &lt;translation-unit-name> &lt;rep> [ { &lt;class-attr> ; ... ; &lt;class-attr> } ]. where &lt;matcher> ::= \"className\" (* E.g. `\"Namespace::Foo\"` *) | (&lt;matcher-expr>) (* E.g. `(name \"Foo\")` or `(exact \"Foo\")` *) &lt;rep> ::= dataclass [ [ &lt;dataclass-attr> ; ... ; &lt;dataclass-attr> ] ] | rep &lt;rep-name> &lt;dataclass-attr> ::= no_register (* Forget about any freshly synthesized model, rep *) | no_cfrac (* Do not synthesize a `CFracSplittable` instance *) &lt;class-attr> ::= (* Additional specs to synthesize *) defaultable (* default constructor *) | destructible (* destructor *) | copyable (* copy constructor, copy assignment *) | movable (* move constructor, move assignment *) | default_specs (* all supported default methods in the TU, and an abbreviation for the lot *) Examples We consider the C++ code // dataclass_demo.hpp namespace Test { class Base { public: int x{0}; Base() = default; }; class Client : public Base { public: int some_client_data{0}; int other_client_data{0}; bool client_has_feature_X{false}; // ... }; }; Using prefix Module Base. cpp.class \"Test::Base\" prefix \"\" from dataclass_demo_hpp.source dataclass[no_cfrac] { defaultable ; copyable ; movable }. End Base. generates, among many things, the model T the representation predicate R a default value of type T the specifications for constructors (including default and copy constructors), destructors, and copy assignment and move assignment operators various properties (but not CFracSplittable), learning hints and unfolding hints for R As the generated definitions are put inside the Module Base with empty prefix, we can refer to them as, for example, Base.T and Base.R, and Base.default_ctor_spec. Meanwhile, cpp.class (exact \"Test::Client\") prefix \"Base_\" from dataclass_demo_hpp.source dataclass { default_specs }. generates Base_T and Base_R and Base_default_ctor_spec, and so on. (exact &quot;Test::Client&quot;) is a matcher expression. Using dataclass dataclass generates the model T as a Record, using the fields of the C++ class/struct, mapping primitives to their known Rocq types (e.g. int to Z) and internal classes/structs to the models registered with dataclass (e.g. those also generated by cpp.class). Meanwhile, the predicates R has type cQp.t -&gt; T -&gt; Rep. For example, in Module Base. cpp.class \"Test::Base\" prefix \"\" from dataclass_demo_hpp.source dataclass { defaultable ; copyable ; movable }. End Base. Module Client. cpp.class \"Test::Client\" prefix \"\" from dataclass_demo_hpp.source dataclass[no_register]. End Client. Print Client.T. gives Record T : Set := Build_T { Test_dot_Base : Base.T; some_client_data : Z; other_client_data : Z; client_has_feature_X : bool } as record. In Module Client, we use dataclass[no_register] to avoid registering the to-be-generated definitions with the dataclass database for known models. Using existing handwritten model and predicate Record MyModel : Set := mkMyModel { x : Z; client : Client.T }. Definition I (m : MyModel) := m.(client).(Client.some_client_data) = m.(client).(Client.other_client_data). br.lock Definition Client_R `{Σ : cpp_logic, σ : genv} (q : cQp.t) (m : MyModel) : Rep := pureR [| I m |] ** Client.R q m.(client). cpp.class \"Test::Client\" from dataclass_demo_hpp.source rep Client_R { copyable ; movable }. generates various hints and properites for Client_R, as well as specifications for copy/move contructors and assignment operators that use MyModel and Client_R. The generated definitions are prefixed by default with Test_Client_, for example, Test_Client_copy_ctor_spec and Test_Client_copy_assign_spec. Using model and predicate generated by derive This approach with derive clutters the environment with CppKeys and so is not recommended. Definition Base := CppKey dataclass_demo_hpp.source \"Test::Base\". #[only(cpp_model,cpp_rep,default_ctor)] derive Base. Definition Client := CppKey dataclass_demo_hpp.source \"Test::Client\". #[only(cpp_model)] derive Client. #[only(cpp_rep)] derive Client. cpp.class (exact \"Test::Client\") prefix \"\" from dataclass_demo_hpp.source rep Client_R { defaultable ; copyable ; movable }."
  },

  {
    "url": "/reference/bluerock.auto.elpi.cpp_enum/",
    "title": "The `cpp.enum` command",
    "content": "Usage #[disable(inj)] (* do not synthesize `Inj eq eq to_val`, etc *) #[verbose, debug] cpp.enum \"name\" from &lt;translation-unit> &lt;kind>. where &lt;translation_unit> ::= &lt;translation-unit-name> | (&lt;translation-unit-expr>) &lt;kind> ::= variant (* one of several, e.g. `enum YesNo { Yes | No };` *) | alias (* an alias of a type, e.g. `enum align_t : size_t {};` *) | newtype (* same as alias, but introduces a new type *) Examples We consider the following C++ code // test.cpp namespace ns { enum E { X , Y }; } enum ALIAS_int : int {}; enum NEW_TYPE_char : char {}; The command Module ns. cpp.enum \"ns::E\" from (test_cpp.source) variant. End ns. generates in Module ns, among many things, the E.t type where Variant t := X | Y. (i.e. constructors E.X and E.Y) functions that convert E.t to Z and N (e.g. E.to_Z) and their injectivity properties EqDecision and Finite instances of E.t The command cpp.enum \"ALIAS_int\" from test_cpp.source alias. generates facts that values of ALIAS_int are convertible with the C++ type int (i.e. they also have the model as Z). The command cpp.enum \"NEW_TYPE_char\" from test_cpp.source newtype. generates the new type NEW_TYPE_char.t that is convertible with the C++ type char (i.e. it also has the model as Z)."
  },

  {
    "url": "/reference/bluerock.auto.elpi.cpp_spec/",
    "title": "The `cpp.spec` command",
    "content": "Usage #[ignore_errors, ignore_missing, convertible, verbose, debug] cpp.spec &lt;matcher> [as &lt;spec-name>] [from &lt;translation-unit>] [template &lt;template-translation-unit>] [with (&lt;spec>) | inline | default | (&lt;constrained-spec>)]. where &lt;matcher> ::= \"f(int)\" | (name \"x\") | ... &lt;spec-name> ::= f_spec &lt;translation-unit> ::= file_hpp.source | (file_hpp.source) &lt;template-translation-unit> ::= file_hpp_templates.source | (file_hpp_templates.source) &lt;spec> ::= &lt;WPP-style-spec> | \\this this &lt;WPP-style-spec> &lt;constrained-spec> ::= \\requires .. \\with &lt;spec> Without from, cpp.spec requires a section variable or Let bindings of type genv (call it σ) and TU ⊧ σ. and are not yet supported for template specifications. Attributes: ignore_errors do not validate \\argument types convertible find a symbol that is &quot;convertible&quot; to this one, e.g. D::foo() is convertible to C::foo() if D extends C. This can be useful when base classes provide methods, but the base classes are implementation details, e.g. in the case of std::atomic and std::atomic_base. When using this feature, the specification should be written according to the written type, e.g. write the spec in terms of C::foo() rather than D::foo(). NOTE: Does not yet support template specifications. ignore_missing rather than failing when a function is not found, generate a trivial specification. This can be useful when trying to support multiple versions of a library. NOTE: Does not yet support template specifications. verbose verbose printing. debug debugging. Examples cpp.spec \"h(int, bool)\" as \"h_spec4\" with ( \\arg{x} \"x\" (Vn x) (* Vn and int are compatible *) \\arg{b} \"b\" (Vbool b) \\post emp ). Definition h_spec_gr : WpSpec_cpp := ( \\arg{x} \"x\" (Vint x) \\arg{b} \"b\" (Vbool b) \\post emp ). cpp.spec \"h(int, bool)\" as \"h_spec5\" with (h_spec_gr). (* wrong types *) Definition h_spec_gr2 : WpSpec_cpp := ( \\arg{x} \"x\" (Vbool x) \\arg{b} \"b\" (Vbool b) \\post emp ). Fail cpp.spec \"h(int, bool)\" as \"h_spec6\" with (h_spec_gr2). cpp.spec \"C::f()\" with ( \\this this \\pre emp \\post emp )."
  },

  {
    "url": "/reference/bluerock.auto.cpp.elpi.derive.bi/",
    "title": "Derive instances for BI predicates",
    "content": "The command derive supports generating, mainly for Rep and mpred, #[global] instances of: Knowledge Timeless ExclusiveToken0 Typed cls _/ Observe (type_ptrR (Tnamed cls)) _ Fractional, FracValid0, AsFractional0 CFractional, CFracValid0, AsCFractional0 WeaklyObjective cfracsplittable derivation generates instances of Timeless, CFractional, AsCFractional0 and CFracValid0, and not CFracSplittable_0. This is also the same for fracsplittable. Locked predicates using mlock and br.lock are supported as well as Parameters. For definitions, the command tries to solve Knowledge by solve_knowledge, Timeless and Typed by solve_TC (the C++ type in Typed is an evar that should be solved by typeclass search); and ExclusiveToken0 by solve_exclusive. The instances can be referred to by the convention [Pred]_[instance type], e.g. R_timeless. Usages: #[only(knowledge)] derive Pred. #[only(timeless)] derive Pred. #[only(exclusive)] derive Pred. #[only(type_ptr)] derive Pred. #[only(timeless,knowledge)] derive Pred. #[only(cfractional,cfracvalid,ascfractional)] derive Pred. #[only(cfracsplittable)] derive Pred. #[only(fractional,fracvalid,asfractional)] derive Pred. #[only(fracsplittable)] derive Pred. #[only(wobjective)] derive Pred. Examples: br.lock Definition prim0R `{Σ : cpp_logic} {σ : genv} (q : cQp.t) : Rep := primR Tint q 0. #[only(timeless)] derive prim0R. This generates the following instance: #[global] Instance prim0R_timeless : ∀ ti _Σ Σ σ q, Timeless (@prim0R ti _Σ Σ σ q). Proof. rewrite prim0R.unlock. apply _. Qed. Meanwhile Parameter R : ∀ `{Σ : !cpp_logic ti _Σ} (q : cQp.t), mpred. #[only(timeless)] derive R. declares the following instance, because R is a Parameter. #[global] Declare Instance R_timeless : ∀ ti _Σ Σ q, Timeless (@R ti _Σ Σ q)."
  },

  {
    "url": "/reference/bluerock.auto.elpi.derive.eager_unfold/",
    "title": "Derive Eager unfolding hints",
    "content": "This command does not yet support usages inside Sections. Usages: #[only(eager_unfold)] derive R. The command defines and registers hints that eagerly unfold/unlock predicates. These hints have locality export. For example Definition R `{Σ : cpp_logic} {σ : genv} q : Rep := Rbody q. #[only(eager_unfold)] derive R. registers a (exported) hint of the form ∀ q, R q -|- Rbody q that will only trigger when the goal contains Rbody q."
  },

  {
    "url": "/reference/bluerock.auto.elpi.derive.equiv/",
    "title": "Derive equivalences for predicates",
    "content": "Usages: #[only(equiv)] derive R. For example, Definition R `{Σ : cpp_logic} {σ : genv} q : Rep := Rbody q. #[only(equiv)] derive R. proves the lemma R_equiv : ∀ q, R q -|- Rbody q."
  },

  {
    "url": "/reference/bluerock.auto.elpi.derive.lazy_unfold/",
    "title": "Derive Lazy unfolding hints",
    "content": "This command does not yet support usages inside Sections. Usages #[only(lazy_unfold(locality)] derive R. where locality ∈ { global, local, export } #[only(lazy_unfold)] derive R. is the same as #[only(lazy_unfold(export))] R. The command defines and registers lazy unfolding hints for R. For example, Definition R `{Σ : cpp_logic} {σ : genv} (q : cQp.t) : Rep := Rbody q. #[only(lazy_unfold)] derive R. registers a (exported) hint of the form ∀ q, R q -|- Rbody q that will only trigger when the goal contains Rbody q."
  },

  {
    "url": "/reference/bluerock.auto.cpp.hints.fractional/",
    "title": "Common UNSAFE hints for `primR`",
    "content": "This file provides hints that can be registered in order to read primitives which is very common. The hints in this file are technically unsafe, but tend to work in practice due to the way that the weakest pre-condition rules work out. You should enable one of the hints, but probably not both. Neither is enabled by default. In cases were you do not need to split your fractions, you can enable. #[local] Hint Resolve UNSAFE_read_prim_cancel : br_opacity. If you do need to split your fractions, you can enable. #[local] Hint Resolve UNSAFE_read_prim_frac_cancel : br_opacity."
  },

  {
    "url": "/reference/bluerock.auto.cpp.specs.inline/",
    "title": "Inlining during verification",
    "content": "Use the class ShouldInlineFunction to mark a function as &quot;inline during verification&quot;. #[local] Instance foo_inline : ShouldInlineFunction \"foo::foo()\" := {}. Note that inlining a function will repeat the proof of the function in (potentially) many places and can therefore be very expensive. Clearly, you should never mark a function inline unless it has a completely automatic proof. These hints should ALMOST ALWAYS be local, and publically visible member functions should never be marked inline. EXCEPTIONS: trivial C++ wrappers might warrant inlining, especially if not used often. For instance, using ShouldInlineFunction for T* operator-&gt;() const { return get_ptr(); } is reasonable."
  },

  {
    "url": "/reference/bluerock.auto.elpi.derive.bwd/",
    "title": "Derive `Bwd` hints",
    "content": "This command does not yet support usages inside Sections. Usage: #[only(DIR)] derive Lem. where Lem is an equivalence forall ..., LHS ... -|- RHS ... or an entailment forall ..., LHS ... |-- RHS ... registers an exported Bwd hint based on Lem: if DIR is bwd or bwd(r2l): replace RHS by LHS (corresponds to [BWD&lt;-]) if DIR = bwd(l2r): replace LHS by RHS (corresponds to [BWD-&gt;], ONLY for Lem being an equivalence) For example, with Lemma lemPQ : P |-- Q. Proof. (* proof of the hint *) Qed. #[only(bwd)] derive lemPQ. is similar to Definition lemPQ_B (* : Bwd P *) := [BWD] lemPQ."
  },

  {
    "url": "/reference/bluerock.auto.elpi.derive.cancel/",
    "title": "Derive `Cancel` hints",
    "content": "This command does not yet support usages inside Sections. Usage: #[only(DIR)] derive Lem. where Lem is an equivalence forall ..., LHS ... -|- RHS ... or an entailment forall ..., LHS ... |-- RHS ... registers an exported Cancel hint based on Lem: if DIR is cancel or cancel(l2r): cancel RHS with LHS (corresponds to [CANCEL-&gt;]). The generated hint has suffix _l2rC. if DIR = cancel(l2r): cancel LHS by RHS (corresponds to [CANCEL&lt;-], ONLY for Lem an equivalence). The generated hint has suffix _r2lC. For example, with Lemma lemPQ : P |-- Q. Proof. (* proof of the hint *) Qed. #[only(cancel)] derive lemPQ. is similar to Definition lemPQ_l2rC (* : Cancel P Q *) := [CANCEL] lemPQ."
  },

  {
    "url": "/reference/bluerock.auto.elpi.derive.fwd/",
    "title": "Derive `Fwd` hints",
    "content": "This command does not yet support usages inside Sections. Usage: #[only(DIR)] derive Lem. where Lem is an equivalence forall ..., LHS ... -|- RHS ... or an entailment forall ..., LHS ... |-- RHS ... registers an exported Fwd hint based on Lem: if DIR is fwd or fwd(l2r): replace LHS by RHS (corresponds to [FWD-&gt;]) if DIR = fwd(l2r): replace RHS by LHS (corresponds to [FWD&lt;-], ONLY for Lem an equivalence) For example, with Lemma lemPQ : P |-- Q. Proof. (* proof of the hint *) Qed. #[only(fwd)] derive lemPQ. is similar to Definition lemPQ_F (* : Fwd P *) := [FWD] lemPQ."
  },

  {
    "url": "/reference/bluerock.auto.elpi.derive.hint_opaque/",
    "title": "Derive `Hint Opaque` annotations",
    "content": "Usage: #[only(hint_opaque)] derive R. to mark R opaque (globally) in the database br_opacity. This is similar to #[global] Hint Opaque R : br_opacity."
  }

]